+++
title = '一、目录结构设计'
date = 2025-09-15T10:54:29+08:00
draft = true
categories = [ "Go" ]
tags = [ "go"]
+++

## 1.1 目录结构设计

> 给代码安个家：后端分层艺术入门

**user-mgr/main.go**

```go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "pong",
		})
	})
	r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
}
```

在我们的 `user-mgr` 服务里的 `main.go` 里的 `ping` 接口写得很开心。但当业务变得复杂时，如果我们把数据库操作、业务逻辑、HTTP响应全都塞在一个文件里，很快就会变成一锅无法维护的“意大利面条”。

为了避免这种灾难，我们需要给代码做“功能分区”，让专业的人（代码块）做专业的事。

我们将借鉴一个高大上的概念—— **DDD（领域驱动设计）** 中的分层思想，引入 `Service` - `Repository` - `DAO` 三层结构。

**先别被 DDD 吓到！** 它本身博大精深，我们今天不是来研究它的哲学，而是像个小偷一样，悄悄“偷”走它几个最实用、最能提升代码整洁度的模式。

**我们的“建筑规划图”如下：**

```shell
user-mgr/
├── internal/
│   ├── domain/       # 领域层：业务核心，“原料”的定义
│   ├── repository/   # 仓库层：数据的“仓库管理员”
│   │   ├── dao/      # 数据访问层：与数据库打交道的“搬运工”
│   │   └── cache/    # 缓存层：（可选）仓库里的“速取窗口”
│   ├── service/      # 服务层：业务逻辑的“总厨”
│   └── web/          # 表现层：与前端打交道的“服务员”
├── main.go
└── pkg/              # 放一些公共工具、包
```

为了让你彻底理解这套结构，我们把 `user-mgr` 服务想象成一家**饭店的后厨**。

-----

### **1.1.1 后厨角色分工 (各层职责)**

**`web` (Handler) - “服务员”**

  * **职责**：只负责和客人（HTTP 请求）打交道。他负责点菜、传菜，确保菜单（请求参数）没写错。
  * **原则**：服务员不应该跑进厨房亲自炒菜。他只需要把菜单递给“总厨”就行了。所以，`web` 层只做参数校验、格式转换等与 HTTP 直接相关的工作。

**`service` - “总厨”**

  * **职责**：后厨的灵魂人物，负责一道菜（一个完整的业务流程）的烹饪。
  * **工作方式**：总厨看着菜单（业务需求），指挥手下的人去干活。他会对“仓库管理员”说：“去，给我拿条鱼和两个土豆来！” 拿到食材后，他会进行“烹饪”（处理业务逻辑），比如是清蒸还是红烧。

**`repository` - “仓库管理员”**

  * **职责**：负责食材（数据）的取用和存储。总厨向他要东西，他保证能拿出来。
  * **工作方式**：总厨（`service`）只管要“一条鱼”，但这条鱼到底是从 **速取冰柜（`cache`）** 里拿的，还是从 **冷库（`database`）** 里现捞的，总厨不关心。**仓库管理员（`repository`）** 自己有一套工作流程，比如：
    1.  先去速取冰柜 (`cache`) 找。
    2.  找不到？再去冷库 (`dao`) 找。
    3.  从冷库找到了，顺手在速取冰柜里也放一份，方便下次快取。
  * **核心价值**：`repository` 对 `service` **屏蔽了数据来源的细节**。未来就算我们饭店升级，把冷库从 MySQL 换成了更高级的 MongoDB，也只需要换掉仓库管理员的具体操作方法 (`dao`)，总厨的工作流程完全不受影响。

**`dao` - “冷库搬运工”**

  * **职责**：只负责和数据库（冷库）这一个地方打交道。
  * **工作方式**：他是最底层的执行者，懂得各种 SQL “咒语”，负责把数据真真切切地从数据库的某个表里捞出来，或者存进去。

**`domain` - “食材/菜品本身”**

  * **职责**：定义我们业务里最核心的东西是什么。在用户服务里，那自然就是“用户 (User)”这个概念。

-----

### **1.1.2 后厨工作流 (调用流程)**

后厨的指挥链条是**单向的、自上而下**的，绝对不允许“以下犯上”！

1.  **点菜 (Request)**: **服务员 (`web`)** 接到菜单，交给 **总厨 (`service`)**。
2.  **备料 (Process)**: **总厨 (`service`)** 看完菜单，指挥 **仓库管理员 (`repository`)** 去拿食材。
3.  **取货 (Storage)**: **仓库管理员 (`repository`)** 指挥 **搬运工 (`dao`)** 去冷库里取货。

<!-- end list -->

  * **绝对禁止**：搬运工 (`dao`) 绕过所有人直接把菜端给服务员 (`web`)，或者服务员 (`web`) 直接冲进冷库 (`dao`) 拿东西。**这就是跨层调用，是架构腐化的开始！**

**出菜 (Response)** 的流程则正好相反，是一层层地往上传递：
`dao` → `repository` → `service` → `web`

-----

### **1.1.3 总结一下**

  * **为什么要有 `repository` 和 `dao` 两层？**
    `repository` 是个“抽象派”，它只承诺“我会把数据搞定”，但不管具体怎么搞。`dao` 是个“实干派”，专门负责用 MySQL (或者别的) 搞定数据。这样分工，以后换数据库，只需要换 `dao` 这个实干派就行了。

  * **`service` 层到底在忙啥？**
    它就是那个发号施令的**总厨**。它的日常就是：问问这个 `repository` 拿到用户数据，问问那个 `repository` 拿到订单数据，然后把这些“领域对象 (domain object)”组合起来，**“卡卡卡”一顿操作**（这就是核心业务逻辑！），最后做成一道精美的菜品，返回给 `web`。

通过这样的分层，每一层的职责都非常清晰。我们的代码就像一个管理有序、效率极高的现代化厨房，而不是一个手忙脚乱、到处油污的苍蝇小馆。

-----

现在，我们就把上一章建立的“饭店后厨”模型，进行一次真实的“开火预演”。

我将沿用之前的风格，将这些代码片段串成一个完整的故事，并在此过程中进行评估、优化，补充一些关键的“幕后细节”，让整个流程更加清晰和健壮。

## 1.2 后厨实战：当一个“用户注册”请求抵达后...

理论讲了这么多，是时候看看我们的“后厨团队”如何处理一份真实的订单了！这份订单就是——**“新用户注册”**。

我们将完整追踪这份订单从“服务员”接单，到“总厨”策划，再到“仓库”存档的全过程，看看我们精心设计的“责任链”是如何优雅运作的。

### 1.2.1 “餐厅开业” - 在 `main` 中组建团队

在处理任何订单之前，餐厅老板（`main`函数）必须在开业时把团队组建好，并明确每个人的“汇报关系”。这就是依赖注入的“组装”阶段。

您原来的 `main.go` 中 `initUser` 函数的逻辑非常清晰，但它更适合住在“后勤中心” `ioc` 包里，而不是待在 `main.go` 这个“大堂”。我们来优化一下，让 `ioc` 包名副其实。

不必关注 `initUser` 函数的所在包位置，这里仅作为展示如何从底层 (`dao`) 开始，一步步创建实例并向上“注入”依赖，最终组装出一个完整的 `UserHandler`。`initWebServer` 的逻辑也同理。

**优化建议**:

  * 将这些初始化函数（“团队组建说明书”）全部挪到 `ioc` 包中。`main.go` 应该只关心“调用说明书来组建团队”，而不关心“说明书”的具体内容。这让 `main.go` 保持干净，职责更单一。

```go
func main() {
	db := ioc.InitDB()
	udl := initUser(db)
	server := initWebServer(udl)

  server.Run(":8021")
}

func initWebServer(userHdl *web.UserHandler) *gin.Engine {
	server := gin.Default()
	userHdl.RegisterRoutes(server)
	return server
}

func initUser(db *gorm.DB) *web.UserHandler {
	ud := dao.NewUserDAO(db)
	repo := repository.NewUserRepository(ud)
	svc := service.NewUserService(repo)
	u := web.NewUserHandler(svc)
	return u
}
```

-----

### 1.2.2 “订单”处理流程

现在，团队组建完毕，一位新客人发来 `POST /users/signup` 请求，订单来了！

**第 1 站：`web.UserHandler` - “服务员”接单**

“服务员”是第一个接触到订单（HTTP 请求）的角色。

```go
// internal/web/user.go
package web

import (
	"net/http"

	"einscat.com/user-mgr/internal/domain"
	"einscat.com/user-mgr/internal/service"

	"github.com/gin-gonic/gin"
)

type UserHandler struct {
	// 服务员（Handler）只认识总厨（Service）
	svc *service.UserService
}

func NewUserHandler(svc *service.SERVICE.UserService) *UserHandler {
	return &UserHandler{
		svc: svc,
	}
}

// RegisterRoutes 负责将 Handler 的各个“上菜”方法注册到路由上
func (h *UserHandler) RegisterRoutes(server *gin.Engine) {
	ug := server.Group("/users")
	ug.POST("/signup", h.SignUp)
}

// SignUp 处理注册请求
func (h *UserHandler) SignUp(ctx *gin.Context) {
	type SignUpReq struct {
		NickName    string `json:"nickname"`
		PhoneNumber string `json:"phone_number"`
		Password    string `json:"password"`
	}

	var req SignUpReq
	// 1. 服务员检查菜单（请求体），看客人是否填对了
	if err := ctx.BindJSON(&req); err != nil {
		// 如果填错了，直接告诉客人，不用麻烦后厨
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request parameters"})
		return
	}
	
	// 2. 将客人的需求翻译成“后厨通用语言”（domain.User）
	err := h.svc.SignUp(ctx, domain.User{
		NickName:    req.NickName,
		PhoneNumber: req.PhoneNumber,
		Password:    req.Password,
	})
	
	// 3. 根据总厨的处理结果，给客人一个回复
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Signup failed"})
		return
	}
	
	ctx.JSON(http.StatusOK, gin.H{"message": "Signup successful"})
}
```

**解读**:

  * `UserHandler` 通过构造函数 `NewUserHandler` 接收了 `UserService` 实例，它只知道有这么个“总厨”可以使唤。
  * `SignUp` 方法做了三件事：解析并校验前端传来的 JSON -\> 调用 `service` 层处理核心业务 -\> 根据 `service` 的返回结果，给前端一个标准的 HTTP 响应。

**第 2 站：`service.UserService` - “总厨”决策**

“总厨”接到了“服务员”递来的标准订单，他需要根据“菜谱”（业务逻辑）来决策。

```go
// internal/service/user.go
package service

import (
	"context"

	"einscat.com/user-mgr/internal/domain"
	"einscat.com/user-mgr/internal/repository"
)

type UserService struct {
	// 总厨（Service）只认识仓库管理员（Repository）
	repo *repository.UserRepository
}

func NewUserService(repo *repository.UserRepository) *UserService {
	return &UserService{
		repo: repo,
	}
}

func (svc *UserService) SignUp(ctx context.Context, u domain.User) error {
	// 菜谱第一步：加密用户密码（重要的业务逻辑！）
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	u.Password = string(hashedPassword)
	
	// 菜谱第二步：通知仓库管理员，把这个新用户信息存档
	return svc.repo.Create(ctx, u)
}
```

**解读**:

  * 对于一个简单的注册流程，`service` 的核心业务逻辑可能就是**密码加密**、**参数校验**等。
  * 它不关心数据最终存在 MySQL 还是 Redis，它只信任 `repository` 这个“仓库管理员”，并把 `domain.User` 这个“后厨通用对象”交给他。
  * 方法中添加 context 是为了保持链路与超时控制。
    既然是注册用户，就需要传入用户的注册信息，所以 SignUp 还需要接收下用户的注册信息。
    上面提到web下的 handler只能使用service层的东西，但是serviec不能使用 web层的内容，这里需要接收用户信息，就需要定义一个User相关的内容，所以这里在与 web、service同级的地方定义个domain包，在里面定义用户的领域对象，然后在 SignUp 方法中接收一个领域对象。

**第 3 站：`repository.UserRepository` - “仓库管理员”的翻译工作**

这是至关重要的一环！“仓库管理员”是连接 **业务世界（`domain`）**和**数据世界（`dao`）** 的桥梁。

在 Repository 层还完成了 `domain.User` 到 `dao.User` 的转换。

```go
// internal/repository/user.go
package repository

import (
	"context"

	"einscat.com/user-mgr/internal/domain"
	"einscat.com/user-mgr/internal/repository/dao"
)

type UserRepository struct {
	// 仓库管理员（Repository）认识档案室的办事员（DAO）
	dao *dao.UserDAO
}

func NewUserRepository(dao *dao.UserDAO) *UserRepository {
	return &UserRepository{
		dao: dao,
	}
}

// Create 负责创建用户
func (r *UserRepository) Create(ctx context.Context, u domain.User) error {
	// 核心职责：将 domain 对象 翻译成 dao 对象
	return r.dao.Insert(ctx, r.toDAO(u))
}

// toDAO 是一个私有辅助函数，负责转换
func (r *UserRepository) toDAO(u domain.User) dao.User {
	return dao.User{
		Id:          u.Id,
		NickName:    u.NickName,
		PhoneNumber: u.PhoneNumber,
		Password:    u.Password,
		// Ctime 在 DAO 层面可以通过 gorm 的 hook 自动填充
	}
}
```

**第 4 站：`dao.UserDAO` - “档案室办事员”的物理操作**

“办事员”是最终的执行者，他只认识和数据库打交道的“档案卡”（`dao.User`），并使用专业的工具 (`gorm`) 将其存档。

```go
// internal/repository/dao/user.go
package dao

import (
	"context"
	"time"
	"gorm.io/gorm"
)

// User 结构体严格对应数据库的 users 表结构
// 这是一个 PO (Persistent Object)
type User struct {
	Id          uint64         `gorm:"primaryKey,autoIncrement"`
	NickName    string
	PhoneNumber string
	Password    string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

type UserDAO struct {
	db *gorm.DB
}

func NewUserDAO(db *gorm.DB) *UserDAO {
	return &UserDAO{
		db: db,
	}
}

// Insert 将一个 dao.User 对象插入数据库
func (dao *UserDAO) Insert(ctx context.Context, u User) error {
	// 使用带有超时的上下文，确保数据库操作不会永远阻塞
	return dao.db.WithContext(ctx).Create(&u).Error
}
```

**解读**:

  * `dao.User` 结构体现在使用了 `gorm` 标签，它和 `users` 表的字段一一对应。
  * `Insert` 方法接收的是 `dao.User`，职责非常纯粹：就是把它存进数据库。

至此，一个“用户注册”请求就走完了它的完整旅程。每层各司其其职，互不干扰，通过依赖注入紧密协作，构成了一套清晰、健壮、易于测试和维护的系统。

---
