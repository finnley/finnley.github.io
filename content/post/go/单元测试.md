+++
title = '单元测试.md'
date = 2025-08-29T02:13:50+08:00
draft = true
categories = [ "Go" ]
tags = [ "go", "单元测试" ]
+++

## HTTP 接口测试

主要记录的事对 Handler 的测试，该测试代码的难点在于：
- 构造 HTTP 请求：Handler 的方法都是处理 HTTP 请求的，所以我们得想办法构造 HTTP 请求
- 验证 HTTP 响应：Handler 的方法返回的响应都是 HTTP 响应，所以我们也需要考虑验证 HTTP 响应

下面是一段关于注册的 Handler 逻辑代码：

```go
func (u *UserHandler) SignUp(ctx *gin.Context) {
	type SignUpReq struct {
		Username string `json:"username"`
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	var req SignUpReq
	// Bind 会根据 Content-Type 来解析数据到 req 里面
	// 如果解析错会直接写会 400 的错误
	if err := ctx.Bind(&req); err != nil {
		return
	}
	fmt.Printf("%v\n", req)

	ok, err := u.emailExp.MatchString(req.Email)
	if err != nil {
		ctx.String(http.StatusOK, "系统错误1")
		return
	}
	if !ok {
		ctx.String(http.StatusOK, "你的邮箱格式不正确")
		return
	}

	ok, err = u.passwordExp.MatchString(req.Password)
	if err != nil { // invalid or unsupported Perl syntax
		// TODO 记录日志
		ctx.String(http.StatusOK, "系统错误2")
		return
	}
	if !ok {
		ctx.String(http.StatusOK, "密码必须大于8位，包含数字、特殊字符")
		return
	}

	// 调用下 service的方法
	{
		err = u.svc.SignUp(ctx, domain.User{
			Username: req.Username,
			Email:    req.Email,
			Password: req.Password,
		})
		if err == service.ErrUserDuplicateEmail {
			ctx.String(http.StatusOK, "邮箱冲突")
			return
		}
		if err != nil {
			ctx.String(http.StatusOK, "系统异常")
			return
		}
	}

	ctx.String(http.StatusOK, "注册成功")
}
```

从上面的代码会发现几个特点：
- 看到存在很多的错误处理分支
- 没有返回值，也就无法判断到底是从哪个分支返回的

想一下，那该如何判断呢？虽然方法没有返回值无法判断从哪里分会，但是仔细看看会发现每个分支的返回都有写响应。所以测试的时候可以测试方法的响应与我预期的是否一致来判断，比如我想测试下面这个逻辑：
```go
if !ok {
	ctx.String(http.StatusOK, "你的邮箱格式不正确")
	return
}
```
那么我预期的就是返回 “你的邮箱格式不正确” 这样的响应。那么接着要思考的问题就是既然这就是我的预期，那我该如何拿到这些预期响应呢？下面就是解决这样的问题。


首先先搭建一个测试的框架：
```go
func TestUserHandler_SignUpLearn(t *testing.T) {
	testCases := []struct {
		name string
	}{}

	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// 如何拿到响应
		})
	}
}
```

需要明确我们要解决的问题是如何拿到响应？

方式就是可以先从HTTP测试的开始。构造请求与响应实际对应的就是单元测试的预期输入与输出。预期输入实际上就是我们输入的注册请求，预期输出就是我们希望它注册成功与否，如果不成功，我们希望知道它失败的原因。

### 构造HTTP请求

![alt text](image-6.png)

接口测试时还是单元测试，没有必要真的要经过网络发起HTTP请求，而是应该考虑使用编程的手段，来构造HTTP请求。

比如上图，我们可以通过控制HTTP方法、URL和传入的Body，构造出任何一种情况。

```go
func TestUserHandler_SignUpLearn(t *testing.T) {
	testCases := []struct {
		name string
	}{}

	// 1、构造请求
	req, err := http.NewRequest(http.MethodPost, "/users/signup", bytes.NewBuffer([]byte(`
{
	"email": "123@test.com",
	"password": "123456"
}
`)))
	req = req
	// 上面是我构造的情况，怎么可能有error，所以可写成下面一定没有error
	require.NoError(t, err)

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// 如何拿到响应
		})
	}
}

```

构造请求会返回两个参数，一个是req，一个是err，什么情况下会产生Error呢？参数错误。这时就好奇了，我自己构造的请求怎么会有Error呢，对于这种情况，我们可以通过 `require.NoError(t, err)` 来要求一定没有error，处理完后就可以继续后面的处理了。


### 获得响应

![alt text](image-7.png)

想象一下我们正常的响应，就是原始的通过网络传输的响应，他是怎么实现的呢？它就好比一根水管，一端往里面注水，经过水管流通，另一端就会立刻出水，网络请求时一端数据一往里写，另一端就可以获取拿到了展示在浏览器上。

现在呢？单元测试中，就像一个罐子，我先将数据往里面写，然后盛放一会（类似端走处理），等到目的地后再从罐子里拿出来。这个响应的过程就是将数据从罐子里拿出来的过程。

这里盛放数据的是什么东西呢？在单元测试中可以看做是 httptest 包里面提供的一个东西，也就是 httptest.Recoder

![alt text](image-8.png)

```go
func TestUserHandler_SignUpLearn(t *testing.T) {
	testCases := []struct {
		name string
	}{}


	// 构造请求
	req, err := http.NewRequest(http.MethodPost, "/users/signup", bytes.NewBuffer([]byte(`
{
	"email": "test@test.com",
	"password": "123456"
}
`)))
	req = req
	// 上面是我构造的情况，怎么可能有error，所以可写成下面一定没有error
	require.NoError(t, err)

	// 构造响应
	resp := httptest.NewRecorder()
	resp = resp



	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// 如何拿到响应
		})
	}
}
```

在resp的响应里面有HTTP Code 还有 Header、Body 等，我们验证预期输出实际上就是在验证Code 和Body。

## 启动服务

现在已经构造了请求，也就是类似客户端已经准备好调用指定接口的准备工作了，就差服务端了，在单元测试中如何启动服务端的HTTP服务呢？如何将接口的路由注册到服务中呢？

在正常代码中需要先先执行 NewUserHandler ，然后再之上注册路由。于是写下下面内容

```go
func TestUserHandler_SignUpLearn(t *testing.T) {
	testCases := []struct {
		name string
	}{}

	// 1、构造server
	server := gin.Default()
	// 这里用不到codeSvc
	h := NewUserHandler(nil, nil)
	h.RegisterRoutes(server)

	// 2、构造请求
	req, err := http.NewRequest(http.MethodPost, "/users/signup", bytes.NewBuffer([]byte(`
{
	"email": "test@test.com",
	"password": "123456"
}
`)))
	req = req
	// 上面是我构造的情况，怎么可能有error，所以可写成下面一定没有error
	require.NoError(t, err)

	// 3、构造响应
	resp := httptest.NewRecorder()
	resp = resp



	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// 如何拿到响应
		})
	}
}
```

NewUserHandler需要两个参数，这里暂时使用两个nil填充，但显然是不可以传入nil的，否则在执行时出现panic，那该如何处理呢？

显然也不能去NewService，因为NewService 也需要参数，也不能传入nil，这又是出现同样的问题，然后可能又在于NewRepository，NewDao，初始化DB，就这样为了解决nil的问题就这样陷入了死循环。

此时就会使用到一个叫 mock 的工具

```shell
go install go.uber.org/mock/mockgen@latest
```

所以现在可以这样写：
```go
func TestUserHandler_SignUpLearn(t *testing.T) {
	testCases := []struct {
		name string
	}{}

	// 1、构造server
	server := gin.Default()
	// 这里用不到codeSvc
	h := NewUserHandler(nil, nil)
	h.RegisterRoutes(server)

	// 2、构造请求
	req, err := http.NewRequest(http.MethodPost, "/users/signup", bytes.NewBuffer([]byte(`
{
	"email": "test@test.com",
	"password": "123456"
}
`)))
	req = req
	// 上面是我构造的情况，怎么可能有error，所以可写成下面一定没有error
	require.NoError(t, err)

	// 3、构造响应
	resp := httptest.NewRecorder()
	resp = resp

	// 4、启动服务
	// 这就是HTTP请求GIN框架的入口，这里GIN会处理这个请求，响应会写会resp
	server.ServeHTTP(resp, req)

	assert.Equal(t, http.StatusOK, resp.Code)
	assert.Equal(t, "注册成功", resp.Body.String())

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// 如何拿到响应
		})
	}
}

```

由于存在不同的测试场景，所以需要改写如下，把上面逻辑放入到for中：
```go
func TestUserHandler_SignUp(t *testing.T) {
	testCases := []struct {
		name     string
		mock     func(ctrl *gomock.Controller) service.UserService
		reqBody  string
		wantCode int
		wantBody Result
	}{
		
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			// 如何拿到响应?
			// 1、构造server
			server := gin.Default()
			// 提取到 匿名结构体切片中
			//userSvc := svcmocks.NewMockUserService(ctrl)
			//codeSvc := svcmocks.NewMockCodeService(ctrl)
			// 这里用不到codeSvc
			h := NewUserHandler(tc.mock(ctrl), nil)
			h.RegisterRoutes(server)

			// 2、构造请求
			req, err := http.NewRequest(http.MethodPost, "/users/signup", bytes.NewBuffer([]byte(tc.reqBody)))
			// 上面是我构造的情况，怎么可能有error，所以可写成下面一定没有error
			require.NoError(t, err)
			req.Header.Set("Content-Type", "application/json")

			// 3、构造响应
			resp := httptest.NewRecorder()

			// 4、启动服务
			// 这就是HTTP请求GIN框架的入口，这里GIN会处理这个请求，响应会写会resp
			server.ServeHTTP(resp, req)
			assert.Equal(t, tc.wantCode, resp.Code)
			assert.Equal(t, tc.wantBody, resp.Body.String())
		})
	}
}

```

对于每一个测试用例就构造一个请求和响应，从而进行测试。