+++
title = '日志模块'
date = 2025-11-15T20:04:31+08:00
draft = true
categories = [ "Programming" ]
tags = [ "programming", "go" ]
+++

# 引入
缺乏日志的现状：

- 无法确认系统状态，出现问题都不知道
- 出现问题难以定位排查

# 日志的通用理论

## 级别

在大多数公司里面，日志都有级别，常见如下：

- DEBUG：最低级别，记录的日志量最多的级别，记录了一些辅助排查问题的信息，一般在开发和测试环境会开启，线上关闭该级别。
- INFO：中性地（不好也不坏）描述了发生了什么。线上一般都在这个级别。
- WARN：系统发生了一些不好的事情，但是还处于可以容忍的范畴。至少会打印这个级别的日志。
- ERROR：系统发生了一些需要你保持关注的事情。

还有一些公司会有一些额外的级别：
- DATA：用来记录请求和响应。个人觉得是不好的实践，因为本身可以用 INFO 来 记录。
- FATAL：一般用来表达非常严重的错误，差不多就是你需要立刻手工介入。个人觉得也不是很好的实践，大部分人难以分清什么时候用 ERROR，什么时候用 FATAL。
- ……

除非是为了刷 KPI，不然不要在公司里面引入很多级别。因为每多一个级别，就多一点学习
和使用成本。


## 什么时候打日志？打什么级别？

实际上，这个也没有标准回答。你可以搜索不同公司发表的最佳实践，就会发现各家也不一样。  
一个原则：如果你怀疑这个地方要不要打日志，那就打上。

我个人的习惯是：

- 统一利用 AOP 机制，记录任何跟第三方交互的请求和响应，包括数据库、缓存、RPC 调用，使用DEBUG 级别，（我和别人的交互）。
- 统一利用 AOP 机制，记录自己的系统接收的请求，以及自己返回的响应，使用 DEBUG 级别，（别人和我的交互）。
- 在开发阶段，使用 DEBUG 记录流程的关键中间结果。
- 怀疑系统可能有问题，但是又不严重的地方，记录 WARN。只有在频繁出现 WARN 的时候，我才会去看看发生了什么事情。
- 部分情况下，任何不可能出问题，或者表达有人攻击系统的地方，记录 ERROR。

记住：宁滥勿缺。也就是宁愿多打一些日志，也不要偷懒。

# zap

## 直接使用zap

**初始化并使用**

```go
func initLogger() {
	logger, err := zap.NewDevelopment()
	if err != nil {
		panic(err)
	}
	zap.L().Info("这是 replace 之前，不会打印出来")
	// 如果你不 replace，直接用 zapx.L()，你啥都打不出来。
	// 之后如果使用 zap.L() 方式就要 replace，如果直接使用 logger 就不需要。
	// Sugar 没多大意义，实际上另一种实现，无需过多关注，平时使用logger即可
	zap.ReplaceGlobals(logger) // 将logger放回去
	zap.L().Info("日志初始化完成")

	type Demo struct {
		Name string `json:"name"`
	}
	zap.L().Info("这是实验参数",
		zap.Error(errors.New("这是一个 error")),
		zap.Int64("id", 123),
		zap.Any("一个结构体", Demo{Name: "hello"}))
}

```

```go
// ReplaceGlobals replaces the global Logger and SugaredLogger, and returns a
// function to restore the original values. It's safe for concurrent use.
func ReplaceGlobals(logger *Logger) func() {
	_globalMu.Lock()
	prev := _globalL
	_globalL = logger
	_globalS = logger.Sugar()
	_globalMu.Unlock()
	return func() { ReplaceGlobals(prev) }
}
```

使用：
```go
zap.L().Error("校验验证码出错", zap.Error(err))
```

```go
// Error logs a message at ErrorLevel. The message includes any fields passed
// at the log site, as well as any fields accumulated on the logger.
func (log *Logger) Error(msg string, fields ...Field) {
	if ce := log.check(ErrorLevel, msg); ce != nil {
		ce.Write(fields...)
	}
}
```

这种方式使用的就是包变量。

## 通过装饰器统一记录日志

**service.go**
```go
func (s *Service) Send(ctx context.Context, biz string, args []string, numbers ...string) error {
	req := sms.NewSendSmsRequest()
	req.SmsSdkAppId = s.appId
	req.SignName = s.signName
	req.TemplateId = ekit.ToPtr[string](biz)
	req.PhoneNumberSet = s.toStringPtrSlice(numbers)
	req.TemplateParamSet = s.toStringPtrSlice(args)

	resp, err := s.client.SendSms(req)
	zap.L().Debug("发送短信", zap.Any("req", req), zap.Any("resp", resp), zap.Error(err))
	if err != nil {
		return fmt.Errorf("腾讯短信服务发送失败: %w", err)
	}

	for _, status := range resp.Response.SendStatusSet {
		if status.Code == nil || *(status.Code) != "Ok" {
			return fmt.Errorf("发送短信失败: %s, %s", *status.Code, *status.Message)
		}
	}

	return nil
}

```

**service/sms/logger/service.go**

```go
type Service struct {
	svc sms.Service
}

func (s *Service) Send(ctx context.Context, biz string, args []string, numbers ...string) error {
	zap.L().Debug("发送短信",
		zap.String("biz", biz),
		zap.Any("args", args))
	err := s.svc.Send(ctx, biz, args, numbers...)
	if err != nil {
		zap.L().Debug("发送短信出现异常", zap.Error(err))
	}
	return err
}

```

## 依赖注入风格

**pkg/zapx/sensitive_log.go**

```go
// 举例演示，了解就行
type MyCore struct {
	zapcore.Core
}

func (c MyCore) Write(entry zapcore.Entry, fds []zapcore.Field) error {
	for _, fd := range fds {
		if fd.Key == "phone" {
			phone := fd.String
			fd.String = phone[:3] + "****" + phone[7:]
		}
	}
	return c.Core.Write(entry, fds)
}

func MaskPhone(key string, value string) zap.Field {
	value = value[:3] + "****" + value[7:]
	return zap.Field{
		Key:    key,
		String: value,
	}
}

```

**internal/service/user.go**
```go
type userService struct {
	repo   repository.UserRepository
	logger *zap.Logger // 独立的log
}


// 1 依赖注入写法
func NewUserService(repo repository.UserRepository, l *zap.Logger) UserService {
	return &userService{
		repo: repo,
		logger: l,
	}
}

// 2 依赖注入简化版写法
func NewUserServiceV1(repo repository.UserRepository, l *zap.Logger) UserService {
	return &userService{
		repo:   repo,
		logger: zap.L(), // 预留了变化空间
	}
}

...
```

**ioc/log.go**

```go
func InitLogger() *zap.Logger {
	l, err := zap.NewDevelopment()
	if err != nil {
		panic(err)
	}
	return l
}

```

**使用**
```go
logger := ioc.InitLogger()
userService := service.NewUserService(userRepository, logger)


service/user.go 中使用：
svc.logger.Info("用户为注册", zap.String("phone", phone))
```

## 独立不共享日志

**ioc/user.go**
```go
// 比如user服务想要一个自己独有的logger，它不想与别人共享
// 所有可以内部初始化并注入进去
// 非依赖注入写法
func InitUserHandler(repo repository.UserRepository) service.UserService {
	l, err := zap.NewDevelopment()
	if err != nil {
		panic(err)
	}
	return service.NewUserService(repo, l)
}

func InitUserHandler(repo repository.UserRepository, l logger.LoggerV1) service.UserService {
	//l, err := zap.NewDevelopment()
	//if err != nil {
	//	panic(err)
	//}
	return service.NewUserService(repo, l)
}

```


# 封装自己的日志接口

这个方式是为了日后扩展更换其他的第三方日志库。

前面介绍的几种方式否直接耦合了zap，现在比如出现了一个更加合适的日志库，想切换到这个日志库，该怎么办呢？

## 风格一

**pkg/logger/types.go**
```go
// 第一种风格接口：
// 自定义日志API，然后把zap.Logger包装成一个实现
type Logger interface {
	Debug(msg string, args ...any)
	Info(msg string, args ...any)
	Warn(msg string, args ...any)
	Error(msg string, args ...any)
}

// 使用
func LoggerExample() {
	var l Logger
	phone := "13312345678"
	l.Info("用户未注册，手机号码是 %s", phone)
}
```

这种风格需要留有占位符。

## 风格二

```go
// 后续代码使用的这种风格
type LoggerV1 interface {
	Debug(msg string, args ...Field)
	Info(msg string, args ...Field)
	Warn(msg string, args ...Field)
	Error(msg string, args ...Field)
}

type Field struct {
	Key   string
	Value any
}

// 使用
func LoggerV1Example() {
	var l LoggerV1
	phone := "13312345678"
	l.Info("用户未注册", Field{
		Key:   "phone",
		Value: phone,
	})
}
```

这种风格特征就是参数都得带名字。

## 风格三

```go
type LoggerV2 interface {
	// args 必须是偶数，并且按照 key-value, key-value 来组织
	Debug(msg string, args ...any)
	Info(msg string, args ...any)
	Warn(msg string, args ...any)
	Error(msg string, args ...any)
}

// 使用
func LoggerV2Example() {
	var l LoggerV2
	phone := "13312345678"
	l.Info("用户未注册", "phone", phone)
}

```

这个风格args的个数必须是偶数，并且按照key-value形式组织


# 自定义日志接口

**pkg/logger/types.go**
```go
type Logger interface {
	Debug(msg string, args ...Field)
	Info(msg string, args ...Field)
	Warn(msg string, args ...Field)
	Error(msg string, args ...Field)
}

type Field struct {
	Key   string
	Value any
}

// 使用
func LoggerExample() {
	var l Logger
	phone := "13312345678"
	l.Info("用户未注册", Field{
		Key:   "phone",
		Value: phone,
	})
}
```

**pkg/logger/zap.go
```go
package logger

import "go.uber.org/zap"

// 封装自己的logger，摆脱第三方依赖
// 这种方式或多或少存在性能损耗
type ZapLogger struct {
	l *zap.Logger
}

func NewZapLogger(l *zap.Logger) *ZapLogger {
	return &ZapLogger{
		l: l,
	}
}

func (z *ZapLogger) Debug(msg string, args ...Field) {
	z.l.Debug(msg, z.toZapFields(args)...)
}

func (z *ZapLogger) Info(msg string, args ...Field) {
	z.l.Info(msg, z.toZapFields(args)...)
}

func (z *ZapLogger) Warn(msg string, args ...Field) {
	z.l.Warn(msg, z.toZapFields(args)...)
}

func (z *ZapLogger) Error(msg string, args ...Field) {
	z.l.Error(msg, z.toZapFields(args)...)
}

// 参数转化，会引入不必要的内存分配和CPU消耗
func (z *ZapLogger) toZapFields(args []Field) []zap.Field {
	res := make([]zap.Field, 0, len(args))
	for _, arg := range args {
		res = append(res, zap.Any(arg.Key, arg.Value))
	}
	return res
}

/**
缺点：参数的转换，会引入不必要的内存分配和CPU小号
*/

```

这种使用的是适配器模式。

它是讲一个类型适配到另外一个接口。

注意：这里说的是类型，也就是A适配到B，那么A可以是一个接口，也可以是一个具体类型。

典型的使用场景：

- 有两个用途类似，但是细节上有所不同的接口，而后将一个接口（类型）适配到另外一个接口。
- 你因为版本升级，出现了两个不同的接口，那么就得把老接口适配到新接口，也可以把新接口适配到老

接口，这取决于你怎么用。
注意：装饰器模式，一直都是同一个接口；而适配器模式，则必然是不同的接口。

**使用**

```go
type userService struct {
	// 总厨（Service）只认识仓库管理员（Repository）
	repo repository.UserRepository
	l    logx.Logger
}

func NewUserService(repo repository.UserRepository, l logx.Logger) UserService {
	return &userService{
		repo: repo,
		l:    l,
	}
}

func (svc *userService) FindOrCreate(ctx context.Context, phone string) (domain.User, error) {
	...
	svc.l.Info("用户未注册", logx.String("phone", phone))
    ...

	return svc.repo.FindByPhone(ctx, phone)
}

```


# 经验

- 打印日志时，msg 中应尽量包含足够的定位信息，方便快速定位，有些人奇技淫巧会输出乱码，然后根据乱码定位，可行但我认为不可取。
- 打印日志时，比较含糊的信息尽量少用，比如：
```go
zap.L().Error("系统异常", zap.Error(err))
```