+++
title = '第十章 保护系统'
date = 2025-11-05T08:47:41+08:00
draft = true
categories = [ "Programming" ]
tags = [ "go", "programming"]
+++



在功能完成之后，现在要进一步考虑保护我们的系统。

一般来说，你要考虑两方面的事情：
- 正常用户会不会搞崩你的系统？
- 如果有人攻击你的系统，你能撑住吗？

对于中小型公司来说，第一条不会是问题。对于大公司来说，就要两条都考虑。

# 系统可能存在的漏洞

现在我们的系统最明显的漏洞就是：
- 任何人都可以注册。
- 任何人都可以登录。

也就是说，万一有一个人，用 shell 脚本拼命给你发注册请求、登录请求，系统负载就会很高。而且这两个请求都会查询数据库，也就是说数据库负载也很高。

![](/images/programming/100.png)

**怎么办？**

这个时候，我们可以考虑，能不能限制住每个人发的请求数量？又或者，限制住系统处理的请求数量？这就是限流。

![](/images/programming/110.png)

# 限流

限流是最常见的保护系统的办法。限流有很多算法，但是都大同小异，后面在微服务架构部分会进一步讲解。
这里我们使用限流，限制每一个用户，每秒最多发送固定数量的请求。
所以问题来了：
- 我怎么认定谁是谁？尤其是在登录和注册这个接口里，都还没登录成功，我都不知道他是谁。
- 我怎么确定我限流的这个阈值应该是多少？每秒 100 还是每秒 200？

## 限流对象

![](/images/programming/120.png)

第一个问题的答案是：用 IP。也就是说我们的限流针对的是 IP。IP 虽然并不能实际意义上代表一个人，但这已经是我们比较好的选择了。

更好的选择是用 MAC 地址或者设备标识符之类的，比如说 CPU 序列号，但是在 Web 端很少用。

APP 端就可以考虑用设备序列号。当然，在使用 IP 的情况下，我们可能会误把不同的人看成是同一个人。但是只要我们限制的阈值不是很小，就不会有问题。

## 限流阈值

![](/images/programming/130.png)

限流阈值应该是多少？

理论上来说，这应该是通过压测来得到的（面试回答这个）。比如说你压测整个系统，发现最多只能撑住每秒 1000 个请求，那么阈值就是 1000。
而我们是针对个人，搞不了压测。所以可以凭借经验来设置，比如说我们正常人手速，一秒钟撑死一个请求，那么就算我们考虑到共享 IP 之类的问题，给个每秒 100 也已经足够了。

## 被限流的请求怎么办？

![](/images/programming/140.png)

如果我每秒处理 100 个请求，那第 101 个请求过来怎么办？

显然，只能拒绝了，也就是返回错误。这个错误，不同公司有不同的规范。如果你自己决策的话，可以返回什么服务器繁忙之类的信息。