+++
title = '第十一章 缓存机制'
date = 2025-11-06T08:47:41+08:00
draft = true
categories = [ "Programming" ]
tags = [ "go", "programming"]
+++

![](/images/programming/150.png)

# 引入缓存

我们并不会直接在 Service 和 Repository 使用 Redis，而是要引入一个缓存，来避免上层业务直接操作 Redis。
同时我们也不是引入一个通用的 Cache，而是为业务编写专门的 Cache。也就是 UserCache

代码片段：

```go
type UserCache struct {
    client     redis.Cmdable
	expiration time.Duration
}

func NewUserCache(client redis.Cmdable) *UserCache {
	return &UserCache{
		client:     client,
		expiration: time.Minute * 15,
	}
}
```

# 代码

```go
package cache

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"einscat.com/observatory/internal/domain"

	"github.com/redis/go-redis/v9"
)

var (
	ErrKeyNotExist = redis.Nil
)

type UserCache struct {
	// 面相接口编程：struct里面包含接口
	// 写法需要使用 redis.Cmdable，而不是使用具体的如 redis.ClusterClient
	client     redis.Cmdable // client可以是单机redis， 也可以是cluster
	expiration time.Duration
}

// 这里就是是依赖注入，也就是我要用 client，我绝对不初始化它，而是由外面传进来
// 依赖注入：我要用 client，我绝对不初始化它，而是由外面传进来
// A 用到了 B，B 一定是接口（尽量不要用局部变量，包字段） ==> 这个保证面向接口
// A 用到了 B，B 一定是A的字段 ==> 为了对比包变量、包方法，这两个都非常缺乏扩展性
// A 用到了 B，A 绝对不自己初始化B，而是外面注入 ==> 为了保持依赖注入和依赖反转
// A 要用什么都让外面传
func NewUserCache(client redis.Cmdable) *UserCache {
	return &UserCache{
		client:     client,
		expiration: time.Minute * 15,
	}
}

// 只要 error 为 nil， 就默认认为 User 一定存在
// 如果没有数据，返回一个特定的 error
func (cache *UserCache) Get(ctx context.Context, id uint64) (domain.User, error) {
	key := cache.key(id)
	// 如果数据不存在，err == redis.Nil
	val, err := cache.client.Get(ctx, key).Bytes()
	if err != nil {
		return domain.User{}, err
	}
	var u domain.User
	err = json.Unmarshal(val, &u)
	return u, err // 注意这里是简单的写法，可以提高测试覆盖率
}

func (cache *UserCache) Set(ctx context.Context, u domain.User) error {
	// 将对象转成json串
	val, err := json.Marshal(u)
	if err != nil {
		return err
	}

	key := cache.key(u.Id)
	return cache.client.Set(ctx, key, val, cache.expiration).Err()
}

func (cache *UserCache) key(id uint64) string {
	return fmt.Sprintf("user:info:%d", id)
}

```