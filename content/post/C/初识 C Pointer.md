+++
title = '初识 C Pointer'
date = 2017-07-08T07:50:33+08:00
draft = false
categories = [ "C" ]
+++

# 初识 C Pointer

## 一、基本概念

**1、指针是什么？**

指针就是地址。

**2、地址又是什么？**

地址是内存单元的编号。

**3、内存单元的编号又是什么？**

- 内存分为了很多单元或者很多小格子，每个格子一个编号。相当于我们的房子，一个房子一个编号，内存是一个格子一个编号，每个格子只能存放8个0或者8个1。
- 内存条中分为了很多小单元。一个单元有8位，可以存放8个0或者8个1，内存单位 `位`，而是 `字节`，也就是不是一个0或者一个1为一个编号，而是8个0或者8个1组合在一起是一个编号。一个字节等于8位。
- 8个0或者8个1是一个编号，接着又是8个0或者8个1是一个编号。这个编号就是地址。

**4、小结**

指针就是地址，指针和地址是一个概念。

## 二、特点

**绕**

其实并不难，无非就是要多想一会。特点如下：

- 可以表示一些复杂的数据结构。
- 可以快速传递数据。
- 可以使函数返回一个以上的值。
- 可以直接访问硬件。
- 能方便处理字符串。
- 是理解面向对象语言中引用的基础。


## 三、Demo

```c
#include "stdio.h"

int main(void) {
  int * p;
  int i = 3;
  int j;

  // p = i;  // ERROR， 类型不一致，p 只能存放 int 类型变量的地址，不能存放int类型变量的值
  // p = 66; // ERROR，原因同上
  p = &i;    // OK

  j = *p;    // 等价于 j = i;
  printf("i = %d, j = %d, *p = %d\n", i, j, *p); // i = 3, j = 3, *p = 3

  return 0;
}
```

**解释**

p 是变量的名字，int * 表示 p 变量存放的是 int 类型变量的地址。
变量意味着在内存中一块空间，这个空间一定是有编号的，这个编号就是变量的地址。
int * p; 不表示定义了一个名字叫做 *p 的变量
int * p; 应该这样理解，p 是变量名，p变量的数据类型是 int *，int * 类型就是存放 int 类型变量地址的类型

p = &i; 表示的含义：
  字面上理解是将 i 的地址发送给 p 了，但是不能只这样理解，还要思考更深层的潜在的含义。

  1、p 保存了 i 的地址，因此 p 指向 i；
  为什么呢？
  因为 p 里面 i 的地址，通过 p 就能找到 i，所以 p 指向 i。比如我知道你的家庭地址，是不是我就可以找到你了。

  2、p 不是 i，i 也不是 p，修改 p 的值不会影响 i 的值，修改 i 的值也不会影响 p 的值；
  为什么呢？
  因为 p 和 i 是两个不同的变量
  我和你都是人嘛，我和你都是有家庭地址的，我家装修了会影响到你家吗？不会，你家装修了会影响到我家吗？也不会

  3、如果一个指针变量指向了某个普通变量，则 *指针变量就 完全等同于这个普通变量（取地址的逆运算）
    例子：
        如果 p 是个指针变量，并且 p 存放了普通变量 i 的地址，则 p 指向了普通变量 i，*p 就完全等同于 i，
        或者所有出现 *p 的地方都可以替换成 i，所有出现 i 的地方都可以替换成 *p

  4、*p 表示的是以 p 的内容为地址的变量，p 的内容就是 i 的地址，以 i 的地址为地址的变量就是 i


## 四、指针分类

1. 基本类型指针
2. 指针和数组
3. 指针和函数
4. 指针和结构体
5. 多级指针

-----

OK，您的“原材料”已收到！分析完毕，现在开始进行“风格化精加工”。

我将保留您文章的核心逻辑和代码示例，但会用一种更轻松、更具探索性的口吻来重新组织和叙述，目标是让一个从未接触过指针的小白，也能像看故事一样轻松地读下去。

-----

### **优化与改写版本**

# 别怕，C语言指针就是个“指路牌”！

欢迎来到C语言世界里最神秘也最强大的区域——指针。

很多人一听到“指针”两个字，脑子里就开始播放“劝退”的BGM。别担心，今天咱们就把它扒个底朝天。你会发现，指针没那么可怕，它就是个非常听话的“指路牌”而已。

## 一、指针三问：它是个啥？从哪来？到哪去？

要理解指针，咱们得先像个侦探一样，问三个直击灵魂的问题。

**1. 指针到底是个啥玩意儿？**
一句话：**指针就是地址。**

**2. 地址又是从哪冒出来的？**
想象一下，你电脑的内存条是个超————大的小区，里面住着成千上万的“小房间”，每个房间都小得只能放下一点点东西。为了能准确找到每个房间，小区管理员（也就是操作系统）给每个房间都分配了一个独一无二的门牌号。

这个\*\*“门牌号”，就是地址\*\*。

**3. “小房间”里装了什么？**
在C语言的世界里，最小的房间单位叫做“字节”（Byte）。你可以把它想象成一个能装下8个小精灵的盒子，每个小精灵要么是0，要么是1。内存小区里的门牌号，就是按“字节”来分的，一个字节一个门牌号。

当我们定义一个变量，比如 `int i = 3;`，计算机会在这个小区里找一个或几个空房间（`int` 类型通常占4个字节，也就是4个小房间），然后把 `3` 这个数值放进去，并且记住这几个房间的起始门牌号。

**小结一下：**

> 内存是个大社区，字节是最小户型，地址是门牌号。而**指针**，就是一张专门用来记录这些“门牌号”的小纸条。它本身也是个变量，只不过它存放的不是普通数值（比如3、100），而是另一个变量的“门牌号”（地址）。

## 二、指针这玩意儿，到底有啥超能力？

你可能会问：“直接用变量名 `i` 不就完了，干嘛非要绕个圈子，用个小纸条去记它的地址？”

问得好！因为指针这个“绕”，能解锁很多C语言的“超能力”：

  * **乾坤大挪移**：当你想把一个很大很复杂的数据（比如一个巨大的结构体）传给一个函数时，不用辛辛苦苦地把它整个复制一遍。你只需要递一张写着它地址的“小纸条”（指针），函数就能顺着地址找到它，效率瞬间起飞！
  * **一人分饰多角**：普通函数一次只能返回一个值，是不是很憋屈？有了指针，你可以让函数悄悄修改好几个外部变量的值，相当于一次返回了多个“结果”。
  * **直捣黄龙**：指针能让你绕过层层限制，直接和硬件的内存地址打交道，进行一些非常底层的骚操作。（新手慎用，容易玩崩！）
  * **庖丁解牛**：在处理字符串（其实就是一串连续的字符）时，指针就像一把锋利的小刀，可以灵活地在字符串中游走、切割、拼接。
  * ...以及更多！它是你理解C++“引用”等高级概念的基石。

总之，学会指针，你的编程能力将从“小米加步枪”升级到“巡航导弹”。

## 三、上代码！是骡子是马，拉出来遛遛

光说不练假把式。来看一段代码，我们将它一帧一帧地慢放解析。

```c
#include <stdio.h> // 更标准的写法是 <stdio.h>

int main(void) {
  int i = 3;   // 电脑在内存小区里找了个窝，住进了数字 3，我们给这个窝起了个别名叫 i
  int *p;      // 声明一个“指针变量” p，它是个“地址记录本”，专门记录 int 类型变量的地址
  int j;       // 声明一个普通的 int 变量 j

  // p = i;    // 错误！p 是“地址记录本”，不能把数字 3 直接写进去。本子是用来记门牌号的，不是用来当草稿纸的！
  // p = 66;   // 同样错误！门牌号 66 是谁家的？你不知道，这就是在瞎指路，很危险！
  
  p = &i;      // 正确！&i 的意思就是“去把 i 的门牌号取出来”，然后把它存进 p 这个“地址记录本”里。
               // 从现在起，p 就指向了 i。

  j = *p;      // 见证奇迹的时刻！*p 的意思就是“顺着 p 记录的门牌号，去那个房子里把东西取出来！”
               // 所以这行代码等价于 j = i;

  printf("i = %d, j = %d, *p = %d\n", i, j, *p); // 输出结果: i = 3, j = 3, *p = 3

  return 0;
}
```

### **代码“慢动作”解析**

这段代码里有两个关键的“神秘符号”：`&` 和 `*`。

1.  **`int *p;` —— 指针的“出生证明”**

      * 看到这句，要这样理解：`p` 是变量名，它的类型是 `int *`。
      * 这里的 `*` 是一个**类型标识**，像个“资格证”，它告诉编译器：“`p` 不是一个普通的整数，它是一个指针，未来它肚子里装的，必须是 `int` 类型变量的地址！”

2.  **`p = &i;` —— “寻址”与“指向”**

      * `&` 在这里是\*\*“取地址运算符”\*\*。`&i` 的作用就是去查询变量 `i` 的家庭住址（内存地址）。
      * 这行代码执行后，`p` 就保存了 `i` 的地址。我们就说：**`p` 指向了 `i`**。
      * **重要！** `p` 和 `i` 是两个完全独立的变量。`p` 是个地址本，`i` 是个小金库。我修改地址本上的记录（让 `p` 指向别的变量），不会影响你金库里的钱。我往金库里存钱或取钱（修改 `i` 的值），地址本上的地址也不会变。

3.  **`j = *p;` —— “按图索骥”**

      * 这里的 `*` 又换了个马甲，它变成了\*\*“解引用运算符”\*\*，可以理解为“按址取物”。
      * 当 `*` 用在一个已经指向了某个变量的指针前面时（比如 `*p`），它的意思就是：“别管 `p` 本身了，我要的是 `p` 指向的那个地方的东西！”
      * 因为 `p` 指向 `i`，所以 `*p` 就等同于 `i` 本身。

**一个黄金法则：**

> 如果一个指针 `p` 指向了普通变量 `i`，那么在代码的任何地方，`*p` 和 `i` 就是**完全等价**的。
>
> 你能写 `j = i;`，就能写 `j = *p;`。
> 你能写 `i = 100;`，就能写 `*p = 100;` (这句话会真的把 `i` 的值改成100！)

## 四、指针世界的冒险地图（预告）

恭喜你！你已经成功踏入了指针世界，并拿到了第一份藏宝图。但这仅仅是个开始，前方还有更广阔的世界等着你探索：

1.  **基本类型指针** (你已解锁 `int *`，还有 `char *`, `float *` 等待探索)
2.  **指针和数组** (你会发现，它们俩是失散多年的亲兄弟！)
3.  **指针和函数** (学习如何用指针解锁函数的隐藏能力)
4.  **指针和结构体** (管理复杂数据的利器)
5.  **多级指针** (指向“地址记录本”的“地址记录本”，比如 `int **p`)

别怕，一步一个脚印，你会发现指针这个强大的工具，将为你打开新世界的大门。