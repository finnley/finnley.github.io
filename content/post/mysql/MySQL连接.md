+++
title = 'MySQL连接'
date = 2024-05-03T14:57:45+08:00
draft = true
categories = [ "MySQL" ]
tags = [ "mysql" ]
+++

目标：学习客户端是如何连接上MySQL的

客户端与 MySQL 的连接方式主要有四种

* TCP/IP 连接
* 命名管道
* 共享内存
* UNIX域套接字

### TCP/IP 连接

* TCP/IP 连接是 MySQL 在任何平台上都提供的连接方式
* TCP/IP 是目前互联网最主流的网络连接方式

像使用 Navicat、JDBC、ODBC 这些方式连接 MySQL ，本上都是一种连接方式，就是 TCP/IP 连接，这种也就是俗称的网络连接。

该连接方式是 MySQL 在任何平台上（Linux、Mac、Windowns 平台）都提供的连接方式。因为 TCP/IP 连接是目前互联网最主流的连接协议方式。<br> 

### MySQL TCP 通讯协议

这里简单介绍下 MySQL TCP 通讯协议(三次握手、四次挥手)：

1. 三次握手建立TCP连接
2. 认证连接（验证客户端是否是合法的用户名和密码来与MySQL服务端通信）
3. 认证通过之后、客户端开始与服务端之间交互
4. 下发SQL，返回结果
4. 断开 MySQL 连接
5. 四次挥手断开 TCP 连接

#### 认证连接

* 服务端 -> 客户端：发送握手初始化包

三次握手建立 TCP 连接连上之后（即TCP/IP三次握手之后），首先是服务端向客户端发送初始握手的包，也就是客户端和服务端连接上之后，不是客户端最先通信的，而是服务端。（比如打电话、进餐馆吃饭） 

打电话类比：比如平时我们生活中的接打电话，别人打电话过来，我们接电话的时候通过会先问“您好，您是哪位”，然后对面回答说他是某某某，这里的别人就是打电话的人就是客户端，我们接电话的人就服务端。

餐饭吃饭类比：我们去餐馆吃饭，已进入餐馆，店家老板通常会说“你好，几位？”或者“你好，吃饭还是吃面”，我们通常会说“两位”或者“吃饭”。

* 客户端-> 服务端：发送验证

接着客户端会回个验证，因为连上去之后首先是验证用户名和密码，如果用户名和密码不对的话，服务端会拒绝提供服务

* 服务端 -> 客户端：认证结果消息

客户端发送验证之后，服务端会回复客户端认证结果消息，认证好之后客户端就可以和服务端通信了

#### 命令执行

* 客户端 -> 服务端：发送命令包（Command Packet）

客户端向服务端发送命令包

* 服务端 -> 客户端：命令包执行完后服务端向客户端发送命令回应包

#### 断开连接

* 客户端 -> 服务器：发送退出命令包

报文格式如下：

![](/img/mysql/110.png)

消息头：前三个Byte和中间的 1Byte 合在一起称为 Header。3字节报文长度、1字节序号

消息体：具体的SQL内容或者执行结果，body里面1字节指令，其余为参数。指令如：切换数据库（0x02），查询指令（0x03）

我们平时在使用比如图形化话客户端觉得没有这么复杂，这些其实都被客户端或者orm框架帮处理了这些东西。背后也都是以这些TCP报文格式发送的。

### 抓包验证

抓包过程就是使用 Navicat 连接 MySQL，下发SQL，然后再断开连接，观察这个过程都做了什么。

我在本地虚拟机搭建了 CentOS7 系统，然后安装了个 MySQL，启动的 3306 端口。

1、打开 Wireshark，抓的是本地，所以选择的是 bridge100 的网卡

![](/img/mysql/120.png)

![](/img/mysql/130.png)

2、打开 Navicat，选择要连接的 MySQL 连接

![](/img/mysql/140.png)

3、随便打开个表，这一步模拟的是下发SQL语句

![](/img/mysql/150.png)

4、断开连接

![](/img/mysql/160.png)

5、点击 Wireshark 停止抓包

![](/img/mysql/170.png)

#### 分析

1、No.7~No.9

![](/img/mysql/180.png)

```
3	2.887089	192.168.64.1	192.168.64.3	TCP	78	64623 → 3306 [SYN, ECE, CWR] Seq=0 Win=65535 Len=0 MSS=1460 WS=64 TSval=1841894204 TSecr=0 SACK_PERM
4	2.888878	192.168.64.3	192.168.64.1	TCP	74	3306 → 64623 [SYN, ACK, ECE] Seq=0 Ack=1 Win=28960 Len=0 MSS=1460 SACK_PERM TSval=2265321 TSecr=1841894204 WS=128
5	2.888986	192.168.64.1	192.168.64.3	TCP	66	64623 → 3306 [ACK] Seq=1 Ack=1 Win=131712 Len=0 TSval=1841894206 TSecr=2265321
```

64623 是我的 MySQL 客户端，也就是我的使用的 Navicat 占用的端口，3306 是我 MySQL 的服务端

No.3：61216 → 3357 <br>
No.4：3306 → 64623 <br>
No.5：64623 → 3306 <br>

上面过程就是典型的三次握手过程。61216 → 3357 是 客户端向 MySQL Server 发送了一个握手信号，然后 3306 → 64623 是 MySQL 服务端回复给客户端，接着 64623 → 3306 又是客户端再回复服务端。

2、三次握手之后是认证连接，这个过程是服务端先说话。

```
6	2.894619	192.168.64.3	192.168.64.1	MySQL	144	Server Greeting  proto=10 version=5.7.42 
```

Server Greeting：服务端向客户端问好 <br>
proto=10：MySQL 的协议版本，告诉客户端 MySQL 的协议版本是10 <br>
version=5.7.42：服务端告诉客户端，MySQL 的版本是5.7.42


3、服务端问好之后，客户端发送给服务端进行认证

```
7	2.894712	192.168.64.1	192.168.64.3	TCP	66	64623 → 3306 [ACK] Seq=1 Ack=79 Win=131648 Len=0 TSval=1841894212 TSecr=2265327
8	2.894849	192.168.64.1	192.168.64.3	MySQL	260	Login Request user=root 
10	2.898268	192.168.64.3	192.168.64.1	MySQL	77	Response  OK 
11	2.898304	192.168.64.1	192.168.64.3	TCP	66	64623 → 3306 [ACK] Seq=195 Ack=90 Win=131648 Len=0 TSval=1841894215 TSecr=2265331
```

服务端问好之后，客户端马上发送登录信息给服务端进行认证，Protocal 一列的值是 MySQL，也就是 Wireshark 抓到的包的分析出协议是 MySQL，就是根据3个字节的头和一个字节的序号中分析出来的。

双击 No.8 查看 MySQL 协议具体内容：

![](/img/mysql/190.png)

会看到连接 MySQL 的用户名和加密后的密码。也就是客户端将用户名和密码都发送给了服务端，上图分为了两块，上面是解析之前的，下面是解析之后的。

最后 `Response  OK` 也就是服务端表示客户端发送的用户名和密码认证连接通过

3、下发SQL

```
11	2.898304	192.168.64.1	192.168.64.3	TCP	66	64623 → 3306 [ACK] Seq=195 Ack=90 Win=131648 Len=0 TSval=1841894215 TSecr=2265331
12	2.898370	192.168.64.1	192.168.64.3	MySQL	88	Request Query
13	2.900520	192.168.64.3	192.168.64.1	MySQL	177	Response  OK 
```

下发SQL过程就是开始进行查询了，双击 No.12 看到下面内容：

![](/img/mysql/200.png)

比如这一过程看到这句话 “Statement: SET NAMES utf8mb4”，这其实是 Navicat 发了很多我没有显示要求发送的东西，这些是它自己显示需要所需的请求，比如按什么字符编码显示。

最后这个请求服务端回复客户端OK

客户端可能还会继续下发一些SQL查询，比如：

```
14	2.900567	192.168.64.1	192.168.64.3	TCP	66	64623 → 3306 [ACK] Seq=217 Ack=201 Win=131520 Len=0 TSval=1841894218 TSecr=2265334
15	2.901497	192.168.64.1	192.168.64.3	MySQL	229	Request Query
16	2.918398	192.168.64.3	192.168.64.1	MySQL	305	Response TABULAR Response 
```

![](/img/mysql/210.png)

4、断开连接

![](/img/mysql/220.png)

双击报文内容如下：

![](/img/mysql/230.png)


这里客户端向服务端发送了 `Request Quit` 的包，告诉服务端，客户端要退出了，接着就是经典的四次挥手的过程：

```
141	13.281639	192.168.64.1	192.168.64.3	TCP	66	64631 → 3306 [FIN, ACK] Seq=310 Ack=2182 Win=131072 Len=0 TSval=1923128852 TSecr=2271812
142	13.287285	192.168.64.3	192.168.64.1	TCP	66	3306 → 64627 [FIN, ACK] Seq=7182 Ack=347 Win=30080 Len=0 TSval=2275720 TSecr=1318555576
143	13.287422	192.168.64.1	192.168.64.3	TCP	66	64627 → 3306 [ACK] Seq=347 Ack=7183 Win=131072 Len=0 TSval=1318555582 TSecr=2275720
144	13.289743	192.168.64.3	192.168.64.1	TCP	66	3306 → 64623 [FIN, ACK] Seq=21077 Ack=1767 Win=35584 Len=0 TSval=2275717 TSecr=1841904598
```

### 命名管道

* 命名管道是针对 Windows 系统的特有的连接方式，它必须在同一台服务器上通信
* 命名管道开启方式：--enable-named-pipe

### 共享内存

客户端和服务端通过一块内存进行通信，客户端要下发什么指令，就将该指令写入到内存中，服务端再从内存中取出来。这个就很明显，必须要在一台机器上进行通信。

* 服务端配置：--shared=memory
* 客户端配置：--protocal=memiry

### UNIX 域套接字

在 Linux（Unix） 系统中有个 `.sock` 文件，往 `.sock` 文件里面写入，另一个从 `.sock` 文件中取，这就是通过 socket 完成的

* 服务端配置：--socket=/tmp/mysql.sock
* 客户端配置：-S=/tmp/mysql.sock

上面的配置并不是表示客户端与和服务端通过一个文件通信，而是它们在 Linux（Unix）操作系统中建了一个 socket，这种也是一种比较流行的方式。但也是局限在一台服务器内。

